<!-- Paste this into a Webflow Embed element -->
<div id="p5-sketch"></div>

<style>
  /* full-screen & behind everything */
  #p5-sketch {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: -1;
    pointer-events: none;
  }
  body { margin: 0; }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>

<script>
  const sketch = (s) => {
    let pieces = [], selected = null, offset;

    s.setup = () => {
      s.createCanvas(s.windowWidth, s.windowHeight);
      const large = 400,
            med   = large/Math.SQRT2,
            small = 200;

      const vertsArr = [
        [[0,0],[large,0],[0,large]],               // big ×2
        [[0,0],[large,0],[0,large]],
        [[0,0],[med,0],[0,med]],                   // medium
        [[0,0],[small,0],[0,small]],               // small ×2
        [[0,0],[small,0],[0,small]],
        [[0,0],[small,0],[small,small],[0,small]], // square
        [[0,0],[small,0],[1.5*small,small],[0.5*small,small]] // parallelogram
      ];

      const cols = [
        '#E08B60', '#D7446C', '#4A90E2',
        '#F4C15F', '#C73177', '#4E2A75', '#84B971'
      ];

      for (let i = 0; i < vertsArr.length; i++) {
        let x, y, angle, newPiece;
        let attempts = 0;
        let overlapping = true;
        
        // Try to find a non-overlapping position
        while (overlapping && attempts < 50) {
          // Pick a random edge: 0=top, 1=right, 2=bottom, 3=left
          const edge = Math.floor(s.random(4));
          if (edge === 0) { // top
            x = s.random(0, s.width);
            y = s.random(-small, small);
          } else if (edge === 1) { // right
            x = s.random(s.width - small, s.width + small);
            y = s.random(0, s.height);
          } else if (edge === 2) { // bottom
            x = s.random(0, s.width);
            y = s.random(s.height - small, s.height + small);
          } else { // left
            x = s.random(-small, small);
            y = s.random(0, s.height);
          }
          angle = s.random(s.TWO_PI);
          newPiece = new Piece(vertsArr[i], x, y, angle, cols[i], s);
          
          // Check if this piece overlaps with any existing pieces
          overlapping = false;
          for (let j = 0; j < pieces.length; j++) {
            if (piecesOverlap(newPiece, pieces[j], s)) {
              overlapping = true;
              break;
            }
          }
          attempts++;
        }
        
        pieces.push(newPiece);
      }
    };

    s.draw = () => {
      s.clear();
      pieces.forEach(p => {
        if (!selected || p !== selected) p.update();
        p.display();
      });
    };

    s.mousePressed = () => {
      for (let i = pieces.length - 1; i >= 0; i--) {
        if (pieces[i].contains(s.mouseX, s.mouseY)) {
          selected = pieces[i];
          offset   = s.createVector(s.mouseX, s.mouseY).sub(selected.pos);
          pieces.push(pieces.splice(i,1)[0]);
          return;
        }
      }
    };

    s.mouseDragged = () => {
      if (selected) {
        const m = s.createVector(s.mouseX, s.mouseY);
        selected.pos = m.sub(offset);
      }
    };

    s.mouseReleased = () => { selected = null; };
    s.windowResized = () => { s.resizeCanvas(s.windowWidth, s.windowHeight); };

    class Piece {
      constructor(verts, x, y, angle, col, s) {
        this.vertices = verts;
        this.pos      = s.createVector(x, y);
        this.angle    = angle;
        this.col      = col;
        this.s        = s;
        // ← new: drift velocity
        this.vel = s.createVector(
          s.random(-0.25, 0.25),
          s.random(-0.25, 0.25)
        );
        // ← new: angular velocity
        this.avel = s.random(-0.00167, 0.00167);
      }

      update() {
        const s = this.s;
        // move
        this.pos.add(this.vel);
        // rotate
        this.angle += this.avel;
        // bounce
        if (this.pos.x < -3*s.width || this.pos.x > 6*s.width)  this.vel.x *= -1;
        if (this.pos.y < -3*s.height || this.pos.y > 6*s.height) this.vel.y *= -1;
      }

      display() {
        const s = this.s;
        s.push();
        s.translate(this.pos.x, this.pos.y);
        s.rotate(this.angle);
        s.fill(this.col);
        s.noStroke();
        s.beginShape();
        this.vertices.forEach(v => s.vertex(v[0], v[1]));
        s.endShape(s.CLOSE);
        s.pop();
      }

      contains(mx, my) {
        const s = this.s;
        const dx = mx - this.pos.x,
              dy = my - this.pos.y,
              tx = dx * s.cos(-this.angle) - dy * s.sin(-this.angle),
              ty = dx * s.sin(-this.angle) + dy * s.cos(-this.angle);
        return pointInPolygon(tx, ty, this.vertices);
      }
    }

    function pointInPolygon(x, y, vs) {
      let inside = false;
      for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        const xi = vs[i][0], yi = vs[i][1],
              xj = vs[j][0], yj = vs[j][1],
              intersect = ((yi > y) !== (yj > y))
                        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function piecesOverlap(p1, p2, s) {
      // Calculate bounding radius for each piece
      const getRadius = (piece) => {
        let maxDist = 0;
        piece.vertices.forEach(v => {
          const dist = Math.sqrt(v[0] * v[0] + v[1] * v[1]);
          if (dist > maxDist) maxDist = dist;
        });
        return maxDist;
      };
      
      const r1 = getRadius(p1);
      const r2 = getRadius(p2);
      const dist = s.dist(p1.pos.x, p1.pos.y, p2.pos.x, p2.pos.y);
      
      // Add extra padding to ensure clear separation
      const minDist = r1 + r2 + 100;
      return dist < minDist;
    }
  };

  new p5(sketch, 'p5-sketch');
</script>
